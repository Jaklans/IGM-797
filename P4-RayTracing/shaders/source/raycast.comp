#version 450
#extension GL_ARB_separate_shader_objects : enable
#define WIDTH 970.0f
#define HEIGHT 540.0f
#define WORKGROUP_SIZE 1

layout(local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_y = 1) in;

layout(binding = 0, rgba8) uniform writeonly image2D outputTexture;


struct sphere{
	vec3 pos;
	float rad;
};

const sphere spheres[] = sphere[2](
	sphere(vec3(1.5,0.5,5.0), 1.0),
	sphere(vec3(-1.2,0.5,3.5), 1.0)
);

struct light{
	vec3 pos;
	vec3 color;
	float intensity;
};

//const light mainLight = light(-10, 3, 20);

struct hitData {
	vec3 pos;
	float distance;
};

//Ray is assumed to be normalized
//Returns vector from sphere center to closest point on ray
vec3 checkSphereIntercept(vec3 ray, sphere sphere){
	return sphere.pos - (dot(ray, sphere.pos) * ray);
}


void main() {
	vec2 coords = vec2(gl_GlobalInvocationID.x / (WIDTH * WORKGROUP_SIZE), gl_GlobalInvocationID.y / (WIDTH * WORKGROUP_SIZE));

	//imageStore(outputTexture, ivec2(gl_WorkGroupID.xy), vec4(gl_GlobalInvocationID.y / (WIDTH * WORKGROUP_SIZE), 0.0, 1.0, 1.0));
	//vec3(0.383022219f, 0.422618270f, 0.821393728)


	vec3 dir = normalize(
		mix(
			vec3( 1.0,0.0,0.0), 
			vec3(-1.0,0.0,0.0),
			coords.x)
		+
		mix(
			vec3(0.0, 1.0,0.0), 
			vec3(0.0,-1.0,0.0),
			coords.y)
		+ vec3(0.0, 0.0, 1.0));

	float val = 0;

	//Handle all Sphere intercections
	hitData result = hitData(vec3(0,0,0),9999999);

	vec3 v;
	for(int i = 0; i < 2; i++){
		v = checkSphereIntercept(dir, spheres[i]);
		if(length(v) < 1.0){
			float x = sqrt(spheres[i].rad * spheres[i].rad - dot(v,v));
			vec3 interceptPoint = spheres[i].pos + v - x * dir;
			float distance = length(interceptPoint);
			if(length(interceptPoint) < result.distance) result = hitData(interceptPoint, distance);
			val = distance;
		}
	}
	if(val < .01){
		imageStore(outputTexture, ivec2(gl_WorkGroupID.xy), vec4(dir,1));
	}
	else{
		imageStore(outputTexture, ivec2(gl_WorkGroupID.xy), vec4(result.pos,1));
	}
}